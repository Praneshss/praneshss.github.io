---
permalink: /
title: "Welcome to my Academic Webpage "
author_profile: true
redirect_from: 
  - /about/
  - /about.html
---


About Me
======
- I'm currently working as a Sr. Embedded Security Researcher at the Technology Innovation Institute in Abu Dhabi, United Arab Emirates.

- I earned my PhD from the Computer Science and Engineering Department at the Indian Institute of Technology (IIT) Kharagpur, India, under the guidance of Prof. Rajat Subhra Chakraborty. My PhD was funded by Intel® Corporation, USA. I was also an Intel® AI Academy Student Ambassador for IIT Kharagpur.

- My primary areas of research interest are: Hardware Security, Embedded Systems Security and PLC Automation.

- Books: Available at this [link](https://link.springer.com/book/10.1007/978-981-19-4017-0). 

- Prior to my PhD, I had worked as a firmware engineer for nearly six years in Bangalore, India.

---
My Work Experience
======
* Technology Innoation Institute (2022 - Now)
* Horner Engineering India (2012-2016)
* Processor Systems (2010-2012)

---
My Teaching Experience (as a TA)
======
* Computer Organisation and Architecture Laboratory (CS39001, CS31007)
* Programming and Data Structures Laboratory (CS11001)
* Machine learning (CS60050)
---

---
My journey into Embedded Wonderland
======
As an engineering grad, who wouldn't be thrilled to land a job at Procsys - one of India's first embedded systems companies that just celebrated 50 years in the game [link](https://www.newindianexpress.com/states/karnataka/2023/Dec/21/one-of-indias-first-computer-companies-this-bengaluru-firm-turns-50-2643504.html). 
However, my confidence quickly turned to panic as I entered a team of seasoned FPGA and hardware experts who spoke different language altogether. Being from a CSE background, I suddenly felt as if I had landed on a different planet. I was assigned to a team working on Nios II, a soft core processor within Altera FPGAs. What!! Soft-core Processors? I couldn't make heads or tails of it. The task assigned was to write a firmware that was supposed to run with Nios-II processor, which itself is a soft-core processor. Buidling and testing my C code would require to build complete hardware design. What!! Even simple C programs took eons to compile. I often found myself pondering with a puzzled look - who would spend hours compiling just a few lines of code?.  Does the code get walkie-talkied to the moon and back before building?. Debugging here was out of the question; compiling felt more like wrestling with limited memory.  It felt akin to playing Tetris on the lowest difficulty level. 'It'll fit, it'll fit!' I kept reassuring myself, 'All is well.' If I breathe in, will I have room left for declaring variables? I often wondered how many times if this was some parallel universe where CSE was taught all wrong! Recalling my UG days with enough memory to write bloated programs felt like a distant dream, as luxurious as dwelling in Mysore Palace or Abu Dhabi Palace.

Later, I transitioned to different job which involved developing firmware around Arm Cortex-M and  application processors and microcontrollers. Initially, it involved developing an embedded Linux application for a ICS (Industry Control Systems) product. With time, As you feel like you have  domain-specific expertise  in embedded software design, there comes aha! production-level time-bound critical bugs. Time is ticking, seconds matter as the customer waits for the fix, one such thing that gave addreline rush is to figureout  some code misfuction in firmware  due to bad blocks in flash memory. Further, experiencing bugs related to  relialibility was something unique. it can work perfectly when someone wrote it but as soon as they depart company bugs may arrive from same part of code. Oh bugs!  Do you reproduce via mitosis when employee leaves the company? 
As I delve deeper in the work, it was IOCTLs and linux driver share. Not to forget about cross-compilations. Please guys "you should  work together harmoniously!" Cross compiling is just like another compiling process However, the catch was, when it finally finished compiling, I often found myself forgetting what I was even coding in the first place. levelling up next was  building embedded linux using old-friend LTIB and newer one Yocto. The struggle of transitioning from simple LTIB to Yocto was real, reminiscent of "bitbaking" for building Linux but also causing some "headscratching" for developers. At one point, I was assigned to implement three-point/five-point touch calibration, only made me stuck and realize  that I'm using linear system of equations in a actual product. all that matrix math would actually be useful someday? Boom! . 

Next, My fascination  started with device identification specifically with intrinsic device identification. it tingled with that research itch.  Pursuing a PhD was the next logical step. 
After all, getting a PhD didn't bring about many changes in me, except now I tend to hear differently when people mention "PUF".
Hope you enjoyed!!
